---
title: "Using custom Python versions"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{custom-python}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This vignette describes the three different ways to initialize the R session's connection to Python using the **rMIDAS** package as well as [**reticulate**](https://github.com/rstudio/reticulate).

## Option 1: Do nothing!
 
rMIDAS relies on Python 3.X to run the MIDAS imputation algorithm. For most users, the default settings in **rMIDAS** will be sufficient. Both `train()` and `complete()` check if Python has been initialized and, if not, run the required setup using the best Python 3 version available on your system (as determined by **reticulate**). The first time you run **rMIDAS** after installation, you may be prompted to install additional Python dependencies.

If a suitable Python version is not found on your system, you will be asked to manually set the path to a Python binary. You can do this using the next option.

## Option 2: 

If the automatic setup returns an error or you wish to use a specific Python binary on your system, you can use the `set_python_env()` function in **rMIDAS**, providing an exact path to your chosen Python binary:

```{r, eval = FALSE}

library(rMIDAS)

set_python_env("~/path/to/bin/python")

# Then proceed as normal...

```

**rMIDAS** will handle the rest of the initialization and setup.

*Note*: **reticulate** only allows you to set a Python binary once per R session, so if you wish to switch to a different Python binary, or have already run `train()` or `convert()`, you will need to restart R prior to using `set_python_env()`.

## Option 3:

If you desire more granular control of the R-Python interface (for instance, to point to a specific virtual or conda environment), it is possible to use **reticulate**'s in-built Python configuration tools. Since these commands are outside of **rMIDAS**, you must also manually call `midas_setup()` after configuring your Python install, e.g.:

```{r, eval = FALSE}

library(rMIDAS)

reticulate::use_condaenv(condaenv = "myenv", required = TRUE)
midas_setup()

# Then proceed as normal...

```

*Notes*: As with option 2, **reticulate** only allows you to set a Python binary once per R session. If you wish to switch to a different Python binary, or have already run `train()` or `convert()`, you will need to restart R prior to changing Python version and then call `midas_setup()`.

Setting `required = TRUE` is advised, to prevent **reticulate** overriding your choice of binary/environment.

## Troubleshooting errors

Sometimes the above three options may fail due to system configuration issues. Here we note a few common issues and fixes.

### Mac defaults to Python 2.7

If you are using a Mac, **reticulate** may be defaulting to Python 2.7 which is not supported by **rMIDAS**. If this is the case you will have to configure the R session to use a Python 3 binary, as in option 2 above, by running:

```{r, eval = FALSE}
set_python_env("/usr/local/bin/python3")
```

### Shared library access

If, after setting a Python binary/virtualenv/conda environment using either **rMIDAS** or **reticulate**, you still get an error, it is worth calling `reticulate::py_discover_config` to check whether the required python binary is visible.

If the `python` path is correct, but `libpython` is `[NOT FOUND]` this suggests that your Python binary does not have shared library support. In which case, either point to an alternative Python binary or reinstall your Python version with shared library enabled. On a Unix/Linux system, and using `pyenv`, this can be done as follows (replacing the version number as required):

```{bash, eval = FALSE}
env PYTHON_CONFIGURE_OPTS="--enable-shared" pyenv install 3.9.0
```

### Broken symlinks using `homebrew`

Having installed a version of Python via `pyenv`, we found that broken symlinks prevented R and **reticulate** from interfacing with this new Python install correctly. 

If users encounter something similar, it is worth checking your Python install is correctly configured within `homebrew`. On a Unix/Linux system, you may find running `brew install python` after `pyenv install 3.8.6` prompts the warning:

```
python@3.8 3.8.6_1 is already installed, it's just not linked
```

which can be easily fixed by calling the following line at the Terminal:

```{bash, eval = FALSE}
brew link python@3.8
```
