})
mods_est <- sapply(models,
function (x) summary(x)$coefficients[,1],
simplify = "cbind")
mods_var <- sapply(models,
function (x) diag(stats::vcov(x)),
simplify = "cbind")
m <- length(models)
Q_bar <- (1/m)*rowSums(mods_est)
U_bar <- (1/m)*rowSums(mods_var)
models_demean <- apply(mods_est, 2, function(x) (x-Q_bar)^2)
B <- (1/(m-1)) * rowSums(models_demean)
Q_bar_var <- U_bar + (1 + (1/m))*B
Q_bar_se <- sqrt(Q_bar_var)
v_m <- (m-1)*(1+(U_bar/((1+m^-1)*B)))^2
if (dof_adjust) {
v_complete <- models[[1]]$df.residual
gamma <- ((1+m^-1)*B)/Q_bar_var
v_obs <- ((v_complete + 1)/(v_complete+3))*v_complete*(1-gamma)
v_corrected <- ((1/v_m) + (1/v_obs))^-1
dof <- v_corrected
} else {
dof <- v_m
}
est = Q_bar
std.err = Q_bar_se
stat = est/std.err
combined_mat <- data.frame(term = names(est),
estimate = est,
std.error = std.err,
statistic =stat,
df = dof,
p.value = 2 * stats::pt(abs(stat), dof, lower.tail = FALSE))
rownames(combined_mat) <- NULL
return(combined_mat)
}
adult_lm <- combine("class_labels ~ hours_per_week + education + sex",
family = binomial(),
adult_complete)
...elt()
#' @param ... Further arguments passed onto `glm()`
#' @export
#' @return Data.frame of combined model results.
#' @examples
#' set.seed(89)
#' test_dfs <- lapply(1:5, function (x) data.frame(a = rnorm(1000),
#'                                                 b = runif(1000),
#'                                                 c = 2*rnorm(1000)))
#'
#' midas_res <- combine("a ~ b + c", df_list = test_dfs)
combine <- function(formula, df_list, dof_adjust = TRUE, ...) {
args <- list(...)
if (is.null(args[['family']])) {
cat("No model family specified -- assuming gaussian model.\n\n")
}
models <- lapply(df_list,
function (x) {
stats::glm(formula, data = x, family = family, ...)
})
mods_est <- sapply(models,
function (x) summary(x)$coefficients[,1],
simplify = "cbind")
mods_var <- sapply(models,
function (x) diag(stats::vcov(x)),
simplify = "cbind")
m <- length(models)
Q_bar <- (1/m)*rowSums(mods_est)
U_bar <- (1/m)*rowSums(mods_var)
models_demean <- apply(mods_est, 2, function(x) (x-Q_bar)^2)
B <- (1/(m-1)) * rowSums(models_demean)
Q_bar_var <- U_bar + (1 + (1/m))*B
Q_bar_se <- sqrt(Q_bar_var)
v_m <- (m-1)*(1+(U_bar/((1+m^-1)*B)))^2
if (dof_adjust) {
v_complete <- models[[1]]$df.residual
gamma <- ((1+m^-1)*B)/Q_bar_var
v_obs <- ((v_complete + 1)/(v_complete+3))*v_complete*(1-gamma)
v_corrected <- ((1/v_m) + (1/v_obs))^-1
dof <- v_corrected
} else {
dof <- v_m
}
est = Q_bar
std.err = Q_bar_se
stat = est/std.err
combined_mat <- data.frame(term = names(est),
estimate = est,
std.error = std.err,
statistic =stat,
df = dof,
p.value = 2 * stats::pt(abs(stat), dof, lower.tail = FALSE))
rownames(combined_mat) <- NULL
return(combined_mat)
}
combine("class_labels ~ hours_per_week + education + sex",
family = binomial(),
adult_complete)
combine("class_labels ~ hours_per_week + education + sex",
family = binomial(),
adult_complete)
combine("class_labels ~ hours_per_week + education + sex",
adult_complete)
load_all()
rm("combine")
combine("class_labels ~ hours_per_week + education + sex",
adult_complete)
adult_complete
adult_lm <- combine("class_labels ~ hours_per_week + education + sex",
adult_complete)
load_all()
adult_lm <- combine("class_labels ~ hours_per_week + education + sex",
adult_complete)
adult_complete[[1]]$class_labels
adult_lm
raw_data <- data.table(a = sample(c("red","yellow","blue",NA),1000, replace = TRUE),
b = 1:1000,
c = sample(c("YES","NO",NA),1000,replace=TRUE),
d = runif(1000,1,10),
e = sample(c("YES","NO"), 1000, replace = TRUE),
f = sample(c("male","female","trans","other",NA), 1000, replace = TRUE))
# Names of bin./cat. variables
test_bin <- c("c","e")
test_cat <- c("a","f")
# Pre-process data
test_data <- convert(raw_data,
bin_cols = test_bin,
cat_cols = test_cat,
minmax_scale = TRUE)
# Run imputations
test_imp <- train(test_data)
# Generate datasets
complete_datasets <- complete(test_imp, m = 5)
complete_datasets[[1]]
complete_datasets[[2]]
complete_datasets[[3]]
complete_datasets[[3]]
complete_datasets[[4]]
test_imp$generate_samples(m=1)
test_imp$generate_samples(m=1L)
tester <- test_imp$generate_samples(m=1L)
tester
test_imp$generate_samples(m=1L)$output_list
draws <- test_imp$generate_samples(m=5L)$output_list
draws
View(draws)
View(draws[[1]])
## Reverse pre-processing steps from convert():
draws_post <- lapply(draws, function(df) {
df <- as.data.table(df)
# Undo scaling
if (unscale) {
num_params <- mid_obj$preproc$minmax_params
num_cols <- names(num_params)
for (j in num_cols) {
set(df, j = j, value = undo_minmax(df[[j]], s_min = num_params[[j]]$min, s_max = num_params[[j]]$max))
}
}
# Add binary labels
if (bin_label) {
bin_params <- mid_obj$preproc$bin_list
bin_cols <- names(bin_params)
for (j in bin_cols) {
set(df, j = j, value = add_bin_labels(df[[j]], one = bin_params[[j]][1], zero = bin_params[[j]][2]))
}
}
if (cat_coalesce) {
cat_params <- mid_obj$preproc$cat_lists
cat_cols <- mid_obj$preproc$cat_names
for (i in 1:length(cat_cols)) {
set(df,
j = cat_cols[[i]],
value = coalesce_one_hot(X = df[,cat_params[[i]], with = FALSE],
var_name = cat_cols[i]))
}
# Remove one-hot columns
df[,do.call("c",cat_params)] <- NULL
}
return(df)
})
View(adult_complete)
View(adult_complete[[1]])
mid_obj <- adult_train
m=10L
unscale = TRUE
bin_label = TRUE
cat_coalesce = TRUE
if (!("midas_base.Midas" %in% class(mid_obj))) {
stop("Trained midas object not supplied to 'mid_obj' argument")
}
if (!("preproc" %in% names(mid_obj))) {
unscale = FALSE
bin_label = FALSE
cat_coalesce = FALSE
}
unscale
draws <- mid_obj$generate_samples(m = as.integer(m))$output_list
library(devtools)
load_all()
(reticulate::py_module_available("numpy"))
raw_data <- data.table(a = sample(c("red","yellow","blue",NA),1000, replace = TRUE),
b = 1:1000,
c = sample(c("YES","NO",NA),1000,replace=TRUE),
d = runif(1000,1,10),
e = sample(c("YES","NO"), 1000, replace = TRUE),
f = sample(c("male","female","trans","other",NA), 1000, replace = TRUE))
# Names of bin./cat. variables
test_bin <- c("c","e")
test_cat <- c("a","f")
# Pre-process data
test_data <- convert(raw_data,
bin_cols = test_bin,
cat_cols = test_cat,
minmax_scale = TRUE)
# Run imputations
test_imp <- train(test_data)
# Generate datasets
complete_datasets <- complete(test_imp, m = 5)
View(complete_datasets[[1]])
View(raw_data)
test_imp$preproc$bin_list
names(test_imp$preproc$bin_list)
mid_obj = test_imp
bin_params <- mid_obj$preproc$bin_list
bin_cols <- names(bin_params)
bin_cols[1]
bin_params[["c"]]
bin_params[["c"]][1]
bin_params[["c"]][2]
unscale = FALSE
cat_coalesce = FALSE
draws <- mid_obj$generate_samples(m = as.integer(m))$output_list
m = 5
draws <- mid_obj$generate_samples(m = as.integer(m))$output_list
df = draws[[1]]
unscale
# Undo scaling
if (unscale) {
num_params <- mid_obj$preproc$minmax_params
num_cols <- names(num_params)
for (j in num_cols) {
set(df, j = j, value = undo_minmax(df[[j]], s_min = num_params[[j]]$min, s_max = num_params[[j]]$max))
}
}
bin_label
bin_label = TRUE
bin_label
bin_params <- mid_obj$preproc$bin_list
bin_cols <- names(bin_params)
View(df)
bin_cols
for (j in bin_cols) {
set(df, j = j, value = add_bin_labels(df[[j]], one = bin_params[[j]][1], zero = bin_params[[j]][2]))
}
View(df)
df[[c]]
if (!("midas_base.Midas" %in% class(mid_obj))) {
stop("Trained midas object not supplied to 'mid_obj' argument")
}
draws <- mid_obj$generate_samples(m = as.integer(m))$output_list
df = draws[[1]]
View(df)
j = bin_cols[1]
j
df[[j]]
add_bin_labels(df[[j]], one = bin_params[[j]][1], zero = bin_params[[j]][2])
bin_params[[j]][1]
bin_params[[j]][2]
df[[j]]
x
df[[j]]
x = df[[j]]
one = "NO"
zero = "YES"
factor(ifelse(x == 1, one,ifelse(x==0,zero,NA)), levels = c(zero, one))
x
rbinom(1,1,1)
rbinom(1,1,1)
rbinom(1,1,1)
rbinom(1,1,1)
rbinom(1,1,1)
rbinom(1,1,1)
rbinom(1,1,0)
rbinom(1,1,0)
rbinom(1,1,0)
rbinom(1,1,0)
rbinom(1,1,0)
rbinom(1,1,0)
rbinom(1,1,0)
rbinom(1,1,0)
rbinom(1,1,0)
rbinom(1,1,0)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.9)
rbinom(1,1,0.9)
rbinom(1,1,0.9)
rbinom(1,1,0.9)
rbinom(1,1,0.9)
rbinom(1,1,0.9)
rbinom(1,1,0.9)
rbinom(1,1,0.9)
rbinom(1,1,0.9)
rbinom(1,1,0.9)
rbinom(1,1,0.9)
rbinom(1,1,0.9)
rbinom(1,1,0.9)
rbinom(1,1,0.9)
rbinom(1,1,1)
rbinom(2,1,1)
rbinom(2,1,0.5)
rbinom(2,1,0.5)
rbinom(2,1,0.5)
rbinom(2,1,0.5)
rbinom(2,1,0.5)
rbinom(2,1,0.5)
rbinom(2,1,0.5)
rbinom(2,1,0.5)
rbinom(5,1,c(1,1,1,0,0))
rbinom(5,1,c(0,0,1,0,0))
rbinom(5,1,c(0,0,1,0,0))
rbinom(5,1,c(0,0,1,0,0))
rbinom(5,1,c(0,0,1,0,0))
rbinom(5,1,c(0,0,1,0,0))
rbinom(5,1,c(0.5,0.5,1,0.5,0.5))
rbinom(5,1,c(0.5,0.5,1,0.5,0.5))
rbinom(5,1,c(0.5,0.5,1,0.5,0.5))
rbinom(5,1,c(0.5,0.5,1,0.5,0.5))
rbinom(5,1,c(0.5,0.5,1,0.5,0.5))
rbinom(5,1,c(0.5,0.5,1,0.5,0.5))
rbinom(5,1,c(0.5,0.5,1,0.5,0.5))
rbinom(5,1,c(0.5,0.5,1,0.5,0.5))
rbinom(5,1,c(0.5,0.5,1,0.5,0.5))
rbinom(5,1,c(0.5,0.5,1,0.5,0.5))
rbinom(5,1,c(0.5,0.5,1,0.5,0.5))
rbinom(5,1,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1,c(0.1,0.1,1,0.9,0.9))
rbinom(5,0,c(0.1,0.1,1,0.9,0.9))
rbinom(5,0,c(0.1,0.1,1,0.9,0.9))
rbinom(5,0,c(0.1,0.1,1,0.9,0.9))
rbinom(5,0,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1000,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1000,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1000,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1000,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1000,c(0.1,0.1,1,0.9,0.9))
rbinom(5,1000,c(0.1,0.1,1,0.9,0.9))
x
rbinom(length(x),1,x)
j
rbinom(length(x),1,x)
rbinom(length(x),1,x)
rbinom(length(x),1,x)
rbinom(length(x),1,x)
rbinom(length(x),1,x)
rbinom(length(x),1,x)
factor(rbinom(length(x),1,x), levels = c(zero, one))
factor(ifelse(rbinom(length(x),1,x)==1, one, zero), levels = c(zero, one))
fast = TRUE
load_all()
test_imp
# Generate datasets
complete_datasets <- complete(test_imp, m = 5)
complete_datasets[[1]]
draws <- mid_obj$generate_samples(m = as.integer(m))$output_list
df = draws[[1]]
df
bin_label
if (bin_label) {
bin_params <- mid_obj$preproc$bin_list
bin_cols <- names(bin_params)
for (j in bin_cols) {
set(df, j = j, value = add_bin_labels(df[[j]],
one = bin_params[[j]][1],
zero = bin_params[[j]][2],
fast))
}
}
fast
df
df = draws[[1]]
x = df[['c']]
x
one = "NO"
zero
fast
fast
X
x
factor(ifelse(x >= 0.5, one, ifelse(x<0.5,zero,NA)),
levels = c(zero, one))
x
x = df[['c']]
x
df = draws[[1]]
df[['c']]
draws <- mid_obj$generate_samples(m = as.integer(m))$output_list
draws[[1]]
draws[[1]][['c']]
x = draws[[1]][['c']]
fast
factor(ifelse(x >= 0.5, one, ifelse(x<0.5,zero,NA)),
levels = c(zero, one))
# Generate datasets
complete_datasets <- complete(test_imp, m = 5)
load_all()
# Generate datasets
complete_datasets <- complete(test_imp, m = 5)
complete_datasets[[1]]$c
# Generate datasets
complete_datasets <- complete(test_imp, m = 5, fast = FALSE)
complete_datasets[[1]][['c']]
View(complete_datasets[[1]])
summary(complete_datasets[[1]])
draws <- mid_obj$generate_samples(m = as.integer(m))$output_list
df == draws[[1]]
df = draws[[1]]
df
View(df)
unscale
unscale
unscale = TRUE
# Undo scaling
if (unscale) {
num_params <- mid_obj$preproc$minmax_params
num_cols <- names(num_params)
for (j in num_cols) {
set(df, j = j, value = undo_minmax(df[[j]], s_min = num_params[[j]]$min, s_max = num_params[[j]]$max))
}
}
bin_label
if (bin_label) {
bin_params <- mid_obj$preproc$bin_list
bin_cols <- names(bin_params)
for (j in bin_cols) {
set(df, j = j, value = add_bin_labels(df[[j]],
one = bin_params[[j]][1],
zero = bin_params[[j]][2],
fast))
}
}
View(df)
cat_coalesce
cat_coalesce = TRUE
if (cat_coalesce) {
cat_params <- mid_obj$preproc$cat_lists
cat_cols <- mid_obj$preproc$cat_names
for (i in 1:length(cat_cols)) {
set(df,
j = cat_cols[[i]],
value = coalesce_one_hot(X = df[,cat_params[[i]], with = FALSE],
var_name = cat_cols[i]))
}
# Remove one-hot columns
df[,do.call("c",cat_params)] <- NULL
}
cat_coalesce
cat_params
cat_cols
for (i in 1:length(cat_cols)) {
set(df,
j = cat_cols[[i]],
value = coalesce_one_hot(X = df[,cat_params[[i]], with = FALSE],
var_name = cat_cols[i]))
}
#' Coalesce one-hot encoding back to a single variable
#'
#' Helper function to reverse one-hot encoding post-imputation.
#' @keywords postprocessing
#' @param X A data.frame, data.table or matrix, for a single variable
#' @param var_name A character string, with the original variable label
#' @import data.table
#' @return A vector of length equal to `nrow(X)`, containing categorical labels corresponding to the columns of `X`
coalesce_one_hot <- function(X, var_name) {
X_copy <- data.table::copy(X)
X_max <- apply(X_copy, 1, which.max)
X_max_cat <- sub(paste0(var_name,"_"),"",names(X_copy))[X_max]
return(X_max_cat)
}
