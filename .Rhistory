}
draws <- mid_obj$generate_samples(m = as.integer(m))$output_list
if ((unscale || bin_label || cat_coalesce)) {
message("Imputations generated. Completing post-imputation transformations.\n")
}
## Reverse pre-processing steps from convert():
draws_post <- lapply(draws, function(df) {
df <- as.data.table(df)
# Undo scaling
if (unscale) {
num_params <- mid_obj$preproc$minmax_params
num_cols <- names(num_params)
for (j in num_cols) {
set(df, j = j, value = undo_minmax(df[[j]], s_min = num_params[[j]]$min, s_max = num_params[[j]]$max))
}
}
# Add binary labels
if (bin_label) {
bin_params <- mid_obj$preproc$bin_list
bin_cols <- names(bin_params)
for (j in bin_cols) {
set(df, j = j, value = add_bin_labels(df[[j]],
one = bin_params[[j]][1],
zero = bin_params[[j]][2],
fast))
}
}
if (cat_coalesce) {
cat_params <- mid_obj$preproc$cat_lists
cat_cols <- mid_obj$preproc$cat_names
for (i in 1:length(cat_cols)) {
set(df,
j = cat_cols[[i]],
value = coalesce_one_hot(X = df[,cat_params[[i]], with = FALSE],
var_name = cat_cols[i],
fast))
}
# Remove one-hot columns
df[,do.call("c",cat_params)] <- NULL
}
return(as.data.frame(df))
})
# --- Save files
if (!is.null(file)) {
message("Saving imputed datasets.\n")
if (is.null(file_root)) {
file_root <- paste0("midas_impute_",format(Sys.time(), "%y%m%d_%H%M%S"))
}
sapply(1:m, function (y) data.table::fwrite(x=draws_post[[y]], file = paste0(file,"/",file_root,"_",y,".csv")))
}
return(draws_post)
}
x_complete <- complete2(x_train, m = 1)
x_train$preproc$cat_names
length(x_train$preproc$cat_names)
1:0
x_train$preproc$cat_lists
is.null(x_train$preproc$cat_lists)
exists(x_train$preproc$cat_lists)
is.null(x_train$preproc$cat_lists)
!is.null(mid_obj$preproc$cat_lists)
!is.null(x_train$preproc$cat_lists)
complete2 <- function(mid_obj,
m=10L,
unscale = TRUE,
bin_label = TRUE,
cat_coalesce = TRUE,
fast = FALSE,
file = NULL,
file_root = NULL) {
if (!inherits(mid_obj,"midas_base.Midas")) {
stop("Trained midas object not supplied to 'mid_obj' argument")
}
if (is.null(options("python_initialised")$python_initialised)) {
python_init()
}
if (!("preproc" %in% names(mid_obj))) {
unscale = FALSE
bin_label = FALSE
cat_coalesce = FALSE
}
draws <- mid_obj$generate_samples(m = as.integer(m))$output_list
if ((unscale || bin_label || cat_coalesce)) {
message("Imputations generated. Completing post-imputation transformations.\n")
}
## Reverse pre-processing steps from convert():
draws_post <- lapply(draws, function(df) {
df <- as.data.table(df)
# Undo scaling
if (unscale) {
num_params <- mid_obj$preproc$minmax_params
num_cols <- names(num_params)
for (j in num_cols) {
set(df, j = j, value = undo_minmax(df[[j]], s_min = num_params[[j]]$min, s_max = num_params[[j]]$max))
}
}
# Add binary labels
if (bin_label) {
bin_params <- mid_obj$preproc$bin_list
bin_cols <- names(bin_params)
for (j in bin_cols) {
set(df, j = j, value = add_bin_labels(df[[j]],
one = bin_params[[j]][1],
zero = bin_params[[j]][2],
fast))
}
}
if (cat_coalesce & !is.null(mid_obj$preproc$cat_lists)) {
cat_params <- mid_obj$preproc$cat_lists
cat_cols <- mid_obj$preproc$cat_names
for (i in 1:length(cat_cols)) {
set(df,
j = cat_cols[[i]],
value = coalesce_one_hot(X = df[,cat_params[[i]], with = FALSE],
var_name = cat_cols[i],
fast))
}
# Remove one-hot columns
df[,do.call("c",cat_params)] <- NULL
}
return(as.data.frame(df))
})
# --- Save files
if (!is.null(file)) {
message("Saving imputed datasets.\n")
if (is.null(file_root)) {
file_root <- paste0("midas_impute_",format(Sys.time(), "%y%m%d_%H%M%S"))
}
sapply(1:m, function (y) data.table::fwrite(x=draws_post[[y]], file = paste0(file,"/",file_root,"_",y,".csv")))
}
return(draws_post)
}
x_complete <- complete2(x_train, m = 1)
View(x_complete[[1]])
x_complete <- complete2(x_train, m = 3)
head(quakes)
x_train$preproc$bin_list
names(x_train$preproc$bin_list)
for (i in names(x_train$preproc$bin_list)) {print("hello")}
complete2 <- function(mid_obj,
m=10L,
unscale = TRUE,
bin_label = TRUE,
cat_coalesce = TRUE,
fast = FALSE,
file = NULL,
file_root = NULL) {
if (!inherits(mid_obj,"midas_base.Midas")) {
stop("Trained midas object not supplied to 'mid_obj' argument")
}
if (is.null(options("python_initialised")$python_initialised)) {
python_init()
}
if (!("preproc" %in% names(mid_obj))) {
unscale = FALSE
bin_label = FALSE
cat_coalesce = FALSE
}
draws <- mid_obj$generate_samples(m = as.integer(m))$output_list
if ((unscale || bin_label || cat_coalesce)) {
message("Imputations generated. Completing post-imputation transformations.\n")
}
## Reverse pre-processing steps from convert():
draws_post <- lapply(draws, function(df) {
df <- as.data.table(df)
# Undo scaling
if (unscale) {
num_params <- mid_obj$preproc$minmax_params
num_cols <- names(num_params)
for (j in num_cols) {
set(df, j = j, value = undo_minmax(df[[j]], s_min = num_params[[j]]$min, s_max = num_params[[j]]$max))
}
}
# Add binary labels
if (bin_label) {
bin_params <- mid_obj$preproc$bin_list
bin_cols <- names(bin_params)
for (j in bin_cols) {
set(df, j = j, value = add_bin_labels(df[[j]],
one = bin_params[[j]][1],
zero = bin_params[[j]][2],
fast))
}
}
cat_params <- mid_obj$preproc$cat_lists
if (cat_coalesce & !is.null(cat_params)) {
cat_cols <- mid_obj$preproc$cat_names
for (i in 1:length(cat_cols)) {
set(df,
j = cat_cols[[i]],
value = coalesce_one_hot(X = df[,cat_params[[i]], with = FALSE],
var_name = cat_cols[i],
fast))
}
# Remove one-hot columns
df[,do.call("c",cat_params)] <- NULL
}
return(as.data.frame(df))
})
# --- Save files
if (!is.null(file)) {
message("Saving imputed datasets.\n")
if (is.null(file_root)) {
file_root <- paste0("midas_impute_",format(Sys.time(), "%y%m%d_%H%M%S"))
}
sapply(1:m, function (y) data.table::fwrite(x=draws_post[[y]], file = paste0(file,"/",file_root,"_",y,".csv")))
}
return(draws_post)
}
x_complete <- complete2(x_train, m = 3)
x_complete <- complete2(x_train, m = 5)
x_complete <- complete2(x_train, m = 5)
x_complete <- complete2(x_train, m = 5)
x_conv <- convert(add_missingness(airquality, prop=0.1),
minmax_scale = TRUE)
x_train <- train(x_conv,
training_epochs = 20,
layer_structure = c(128,128),
input_drop = 0.75,
seed = 89)
x_complete <- complete2(x_train, m = 5)
airquality
head(airquality)
x_conv <- convert(add_missingness(airquality, prop=0.1),
minmax_scale = TRUE)
x_train <- train(x_conv,
training_epochs = 20,
layer_structure = c(128,128),
input_drop = 0.75,
seed = 89)
x_complete <- complete2(x_train, m = 5)
rm(complete2)
detach("package:rMIDAS", unload = TRUE)
library(devtools)
install.packages("devtools")
library(devtools)
load_all()
??rMIDAS
data(quakes)
data(airquality)
x_conv <- convert(add_missingness(airquality, prop=0.1),
minmax_scale = TRUE)
x_train <- train(x_conv,
training_epochs = 20,
layer_structure = c(128,128),
input_drop = 0.75,
seed = 89)
mid_py_setup()
reticulate::py_available()
reticulate::py_config()
library(devtools)
load_all()
library(devtools)
load_all()
data(quakes)
x_conv <- convert(add_missingness(quakes, prop=0.1),
minmax_scale = TRUE)
x_train <- train(x_conv,
training_epochs = 20,
layer_structure = c(128,128),
input_drop = 0.75,
seed = 89)
x_train <- train(x_conv,
training_epochs = 20,
layer_structure = c(128,128),
input_drop = 0.75,
seed = 89)
x_train <- train(x_conv,
training_epochs = 20,
layer_structure = c(128,128),
input_drop = 0.75,
seed = 89)
x_train <- train(x_conv,
training_epochs = 20,
layer_structure = c(128,128),
input_drop = 0.75,
seed = 89)
x_train <- train(x_conv,
training_epochs = 20,
layer_structure = c(128,128),
input_drop = 0.75,
seed = 89)
data(airquality)
x_conv <- convert(add_missingness(airquality, prop=0.1),
minmax_scale = TRUE)
x_train <- train(x_conv,
training_epochs = 20,
layer_structure = c(128,128),
input_drop = 0.75,
seed = 89)
load_all()
load_all()
x_train <- train(x_conv,
training_epochs = 20,
layer_structure = c(128,128),
input_drop = 0.75,
seed = 89)
library(devtools)
load_all()
data(airquality)
x_conv <- convert(add_missingness(airquality, prop=0.1),
minmax_scale = TRUE)
x_train <- train(x_conv,
training_epochs = 20,
layer_structure = c(128,128),
input_drop = 0.75,
seed = 89)
library(devtools)
load_all()
data(airquality)
x_conv <- convert(add_missingness(airquality, prop=0.1),
minmax_scale = TRUE)
x_train <- train(x_conv,
training_epochs = 20,
layer_structure = c(128,128),
input_drop = 0.75,
seed = 89)
x_complete <- complete2(x_train, m = 5)
x_complete <- complete(x_train, m = 5)
x_complete <- complete(x_train, m = 5)
library(devtools)
load_all()
data(airquality)
x_conv <- convert(add_missingness(airquality, prop=0.1),
minmax_scale = TRUE)
x_train <- train(x_conv,
training_epochs = 20,
layer_structure = c(128,128),
input_drop = 0.75,
seed = 89)
library(devtools)
load_all()
set_python_env(x = "rmidas-env", type = "conda")
data(airquality)
x_conv <- convert(add_missingness(airquality, prop=0.1),
minmax_scale = TRUE)
x_train <- train(x_conv,
training_epochs = 20,
layer_structure = c(128,128),
input_drop = 0.75,
seed = 89)
reticulate::conda_list()
reticulate::conda_version()
reticulate::py_available()
reticulate::py_discover_config()
x_complete <- complete(x_train, m = 5)
library(devtools)
load_all()
data(airquality)
set_python_env(x = "rmidas-env", type = "conda")
x_conv <- convert(add_missingness(airquality, prop=0.1),
minmax_scale = TRUE)
x_train <- train(x_conv,
training_epochs = 20,
layer_structure = c(128,128),
input_drop = 0.75,
seed = 89)
x_complete <- complete(x_train, m = 5)
library(devtools)
load_all()
library(Amelia)
library(amelia)
install.packages("Amelia")
library(amelia)
library(Amelia)
library(devtools)
load_all()
cat("## \n",
"## rMIDAS: Multiple Imputation using Denoising Autoencoders \n",
"## Authors: Thomas Robinson and Ranjit Lall \n",
"## Please visit https://github.com/MIDASverse/rMIDAS for more information \n",
"## \n"
)
cat("## \n",
"## rMIDAS: Multiple Imputation using Denoising Autoencoders \n",
"## Authors: Thomas Robinson and Ranjit Lall \n",
"## Please visit https://github.com/MIDASverse/rMIDAS for more information \n",
"## \n"
)
cat(" ## \n",
"## rMIDAS: Multiple Imputation using Denoising Autoencoders \n",
"## Authors: Thomas Robinson and Ranjit Lall \n",
"## Please visit https://github.com/MIDASverse/rMIDAS for more information \n",
"## \n"
)
library(devtools)
load_all()
message(" ## \n",
"## rMIDAS: Multiple Imputation using Denoising Autoencoders \n",
"## Authors: Thomas Robinson and Ranjit Lall \n",
"## Please visit https://github.com/MIDASverse/rMIDAS for more information \n",
"## \n"
)
library(devtools)
load_all()
library(devtools)
load_all()
vignette(package = "rMIDAS")
library(devtools)
load_all()
vignette(package="rMIDAS")
vignette(package="rMIDAS")
check()
library(roxygen2)
detach("package:roxygen2", unload = TRUE)
remove.packages("roxygen2")
install_version("roxygen2", version = 7.1.1)
install_version("roxygen2", version = "7.1.1")
check()
library(devtools)
load_all()
check()
?.onAttach
library(devtools)
check()
check()
use_github_action_check_release()
check()
check_rhub()
check_rhub()
rhub::validate_email("ts.robinson1994@gmail.com")
check_rhub()
R.version
check_rhub
library(devtools)
check_rhub()
check_win_devel()
check_win_release()
check()
spell_check()
revdep_check()
release()
install_github("MIDASverse/rMIDAS")
library(rMIDAS)
set_python_env(x = "rmidas-env", type = "conda")
?rmidas
??rMIDAS
vignettes("rMIDAS")
vignette("rMIDAS")
vignette(packge = "rMIDAS")
vignette(package = "rMIDAS")
library(devtools)
install_github("MIDASverse/rMIDAS")
library(rMIDAS)
vignette(package = "rMIDAS")
library(devtools)
check()
release()
library(Amelia)
data(quakes)
quakes_missing <- add_missingess(quakes)
library(rMIDAS)
quakes_missing <- add_missingess(quakes)
quakes_missing <- add_missingess(quakes)
quakes_missing <- add_missingness(quakes)
quakes_missing <- add_missingness(quakes, 0.1)
amelia(quakes_missing, m = 1)
quakes_complete <- amelia(quakes_missing, m = 1)
quakes_complete$imputations[[1]]
quakes$cat <- sample(c("a","b","c"), length(quakes), replace = TRUE)
quakes
quakes_missing <- add_missingness(quakes, 0.1)
quakes_complete$imputations[[1]]
quakes_complete <- amelia(quakes_missing, m = 1)
quakes_complete <- amelia(quakes_missing, m = 1, noms = c("cat"))
quakes_complete$imputations$imp1
library(Amelia)
data(quakes)
quakes
quakes$cat <- sample(c("a","b","c"), nrow(quakes), replace = TRUE)
quakes
quakes <- add_missingness(quakes, 0.3)
quakes
quakes$ord <- sample(c("1","2","3","4","5"), nrow(quakes), replace = TRUE)
quakes
data(quakes)
quakes$cat <- sample(c("a","b","c"), nrow(quakes), replace = TRUE)
quakes$ord <- sample(c("1","2","3","4","5"), nrow(quakes), replace = TRUE)
quakes
quakes <- add_missingness(quakes, 0.3)
quakes
quakes_complete <- amelia(quakes, m = 1,
noms = c("cat"),
ords = c("ord"))
quakes_complete <- amelia(quakes, m = 1,
noms = c("cat"))
data(quakes)
quakes$cat <- sample(c("a","b","c"), nrow(quakes), replace = TRUE)
quakes$ord <- as.factor(sample(c("1","2","3","4","5"), nrow(quakes), replace = TRUE))
quakes
quakes <- add_missingness(quakes, 0.3)
quakes
quakes_complete <- amelia(quakes, m = 1,
noms = c("cat"),
ords = c("ord"))
levels(quakes$ord)
quakes$ord <- factor(sample(c("1","2","3","4","5"), nrow(quakes), replace = TRUE),
levels = c("1","2","3","4","5"))
levels(quakes$ord)
data(quakes)
quakes$cat <- sample(c("a","b","c"), nrow(quakes), replace = TRUE)
quakes$ord <- factor(sample(c("1","2","3","4","5"), nrow(quakes), replace = TRUE),
levels = c("1","2","3","4","5"))
quakes
quakes <- add_missingness(quakes, 0.3)
quakes
quakes
quakes_complete <- amelia(quakes, m = 1,
noms = c("cat"),
ords = c("ord"))
quakes_data <- quakes_complete$imputations$imp1
quakes_data
