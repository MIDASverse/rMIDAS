name_errs <- all_names[!(all_names %in% names(data))]
stop("The following column names could not be found in the data: ",
paste0("'",name_errs,sep="' "))
}
# Check no overlap between bin and cat
if (length(intersect(bin_cols, cat_cols)) > 0) {
stop("At least one variable name is duplicated in the binary and categorical arguments.")
}
# Convert to data.table if data.frame
if (!("data.table" %in% class(data))) {
data.table::setDT(data)
}
# Separate the data by class
data_bin <- data[,bin_cols, with = FALSE]
data_cat <- data[,cat_cols, with = FALSE]
data_num <- data[,setdiff(names(data),all_names), with = FALSE]
# One-hot encode categorical
data_cat[,(cat_cols):=lapply(.SD, as.factor),.SDcols=cat_cols]
data_cat_oh <- mltools::one_hot(data_cat, cols = names(data_cat))
names(data_cat_oh)
cat_lists <- lapply(cat_cols,
function(x) c(names(data_cat_oh)[startsWith(names(data_cat_oh),paste0(x,"_"))]))
## Check binary columns
# List to store conversions
bin_labs <- list()
# For each binary column, check they are indeed binary,
#   convert if necessary, and store corresponding labels
for (bin_col in bin_cols) {
b_vals <- c(unique(data_bin[,bin_col, with=FALSE]))[[1]]
if (!(sum(!is.na(b_vals)) == 2)) {
stop("Column '",,"' specified in bin_cols but does not have two non-missing values")
} else if (sum(b_vals[!is.na(b_vals)] %in% c(1,2)) != 2) {
data_bin[,bin_col] <- ifelse(data_bin[,bin_col, with = FALSE] == b_vals[!is.na(b_vals)][1],
1L,0L)
}
bin_labs[[bin_col]] <- b_vals[!is.na(b_vals)]
}
data_conv <- cbind(data_num, data_bin, data_cat_oh)
type_check <- data_conv[,lapply(.SD, is.character)]
if (sum(type_check == TRUE) > 0) {
type_vars <- names(type_check)[type_check == TRUE]
warning("The following columns have not been converted to a numeric type: ",
paste0("'",type_vars, sep ="' "))
}
out <- list(data = data_conv,
bin_list = bin_labs,
cat_lists = cat_lists)
attr(out, "class") <- "midas_preproc"
return(out)
}
data = data.frame(a = sample(c("red","yellow","blue",NA),100, replace = TRUE),
b = 1:100,
c = sample(c("YES","NO",NA),100,replace=TRUE),
d = runif(100),
e = sample(c("YES","NO"), 100, replace = TRUE),
f = sample(c("male","female","trans","other",NA), 100, replace = TRUE))
bin <- c("c","e")
cat <- c("a","f")
convert(data, bin_cols = bin, cat_cols = cat)
test<-convert(data, bin_cols = bin, cat_cols = cat)
class(test)
class(test$data)
document()
?convert
document()
?convert
scale(c(1,0,1,1))
#'                   b = 1:100,
#'                   c = sample(c("YES","NO",NA),100,replace = TRUE),
#'                   d = runif(100),
#'                   e = sample(c("YES","NO"), 100, replace = TRUE),
#'                   f = sample(c("male","female","trans","other",NA), 100, replace = TRUE))
#'
#' bin <- c("c","e")
#' cat <- c("a","f")
#'
#' convert(data, bin_cols = bin, cat_cols = cat)
convert <- function(data, bin_cols, cat_cols, minmax_scale = FALSE) {
# Check all column names are present
all_names <- c(bin_cols, cat_cols)
if (sum(all_names %in% names(data)) != length(all_names)) {
name_errs <- all_names[!(all_names %in% names(data))]
stop("The following column names could not be found in the data: ",
paste0("'",name_errs,sep="' "))
}
# Check no overlap between bin and cat
if (length(intersect(bin_cols, cat_cols)) > 0) {
stop("At least one variable name is duplicated in the binary and categorical arguments.")
}
# Convert to data.table if data.frame
if (!("data.table" %in% class(data))) {
data.table::setDT(data)
}
# Separate the data by class
data_bin <- data[,bin_cols, with = FALSE]
data_cat <- data[,cat_cols, with = FALSE]
data_num <- data[,setdiff(names(data),all_names), with = FALSE]
num_cols <- names(data_num)
# One-hot encode categorical
data_cat[,(cat_cols):=lapply(.SD, as.factor),.SDcols=cat_cols]
data_cat_oh <- mltools::one_hot(data_cat, cols = names(data_cat))
names(data_cat_oh)
cat_lists <- lapply(cat_cols,
function(x) c(names(data_cat_oh)[startsWith(names(data_cat_oh),paste0(x,"_"))]))
## Check binary columns
# List to store conversions
bin_labs <- list()
# For each binary column, check they are indeed binary,
#   convert if necessary, and store corresponding labels
for (bin_col in bin_cols) {
b_vals <- c(unique(data_bin[,bin_col, with=FALSE]))[[1]]
if (!(sum(!is.na(b_vals)) == 2)) {
stop("Column '",,"' specified in bin_cols but does not have two non-missing values")
} else if (sum(b_vals[!is.na(b_vals)] %in% c(1,2)) != 2) {
data_bin[,bin_col] <- ifelse(data_bin[,bin_col, with = FALSE] == b_vals[!is.na(b_vals)][1],
1L,0L)
}
bin_labs[[bin_col]] <- b_vals[!is.na(b_vals)]
}
# Min-max scale
if (minmax_scale) {
data_num[,(num_cols):=lapply(.SD, col_minmax),.SDcols=num_cols]
}
data_conv <- cbind(data_num, data_bin, data_cat_oh)
type_check <- data_conv[,lapply(.SD, is.character)]
if (sum(type_check == TRUE) > 0) {
type_vars <- names(type_check)[type_check == TRUE]
warning("The following columns have not been converted to a numeric type: ",
paste0("'",type_vars, sep ="' "))
}
out <- list(data = data_conv,
bin_list = bin_labs,
cat_lists = cat_lists)
attr(out, "class") <- "midas_preproc"
return(out)
}
data = data.frame(a = sample(c("red","yellow","blue",NA),100, replace = TRUE),
b = 1:100,
c = sample(c("YES","NO",NA),100,replace=TRUE),
d = runif(100,5,3),
e = sample(c("YES","NO"), 100, replace = TRUE),
f = sample(c("male","female","trans","other",NA), 100, replace = TRUE))
data = data.frame(a = sample(c("red","yellow","blue",NA),100, replace = TRUE),
b = 1:100,
c = sample(c("YES","NO",NA),100,replace=TRUE),
d = runif(100,1,10),
e = sample(c("YES","NO"), 100, replace = TRUE),
f = sample(c("male","female","trans","other",NA), 100, replace = TRUE))
bin <- c("c","e")
cat <- c("a","f")
#'                   b = 1:100,
#'                   c = sample(c("YES","NO",NA),100,replace = TRUE),
#'                   d = runif(100),
#'                   e = sample(c("YES","NO"), 100, replace = TRUE),
#'                   f = sample(c("male","female","trans","other",NA), 100, replace = TRUE))
#'
#' bin <- c("c","e")
#' cat <- c("a","f")
#'
#' convert(data, bin_cols = bin, cat_cols = cat)
convert <- function(data, bin_cols, cat_cols, minmax_scale = FALSE) {
# Check all column names are present
all_names <- c(bin_cols, cat_cols)
if (sum(all_names %in% names(data)) != length(all_names)) {
name_errs <- all_names[!(all_names %in% names(data))]
stop("The following column names could not be found in the data: ",
paste0("'",name_errs,sep="' "))
}
# Check no overlap between bin and cat
if (length(intersect(bin_cols, cat_cols)) > 0) {
stop("At least one variable name is duplicated in the binary and categorical arguments.")
}
# Convert to data.table if data.frame
if (!("data.table" %in% class(data))) {
data.table::setDT(data)
}
# Separate the data by class
data_bin <- data[,bin_cols, with = FALSE]
data_cat <- data[,cat_cols, with = FALSE]
data_num <- data[,setdiff(names(data),all_names), with = FALSE]
num_cols <- names(data_num)
# One-hot encode categorical
data_cat[,(cat_cols):=lapply(.SD, as.factor),.SDcols=cat_cols]
data_cat_oh <- mltools::one_hot(data_cat, cols = names(data_cat))
names(data_cat_oh)
cat_lists <- lapply(cat_cols,
function(x) c(names(data_cat_oh)[startsWith(names(data_cat_oh),paste0(x,"_"))]))
## Check binary columns
# List to store conversions
bin_labs <- list()
# For each binary column, check they are indeed binary,
#   convert if necessary, and store corresponding labels
for (bin_col in bin_cols) {
b_vals <- c(unique(data_bin[,bin_col, with=FALSE]))[[1]]
if (!(sum(!is.na(b_vals)) == 2)) {
stop("Column '",,"' specified in bin_cols but does not have two non-missing values")
} else if (sum(b_vals[!is.na(b_vals)] %in% c(1,2)) != 2) {
data_bin[,bin_col] <- ifelse(data_bin[,bin_col, with = FALSE] == b_vals[!is.na(b_vals)][1],
1L,0L)
}
bin_labs[[bin_col]] <- b_vals[!is.na(b_vals)]
}
# Min-max scale
if (minmax_scale) {
data_num[,(num_cols):=lapply(.SD, col_minmax),.SDcols=num_cols]
}
data_conv <- cbind(data_num, data_bin, data_cat_oh)
type_check <- data_conv[,lapply(.SD, is.character)]
if (sum(type_check == TRUE) > 0) {
type_vars <- names(type_check)[type_check == TRUE]
warning("The following columns have not been converted to a numeric type: ",
paste0("'",type_vars, sep ="' "))
}
out <- list(data = data_conv,
bin_list = bin_labs,
cat_lists = cat_lists)
attr(out, "class") <- "midas_preproc"
return(out)
}
test<-convert(data, bin_cols = bin, cat_cols = cat)
test$data
test<-convert(data, bin_cols = bin, cat_cols = cat, minmax_scale = TRUE)
col_minmax <- function(x) {
(x-min(x))/(max(x)-min(x))
}
test<-convert(data, bin_cols = bin, cat_cols = cat, minmax_scale = TRUE)
test$data
document()
?col_minmax
lapply(data_num, 2, function(x) {return(list(min = min(x, na.rm = TRUE),
max = max(x, na.rm = TRUE)))})
lapply(data_num, function(x) {return(list(min = min(x, na.rm = TRUE),
max = max(x, na.rm = TRUE)))})
# Convert to data.table if data.frame
if (!("data.table" %in% class(data))) {
data.table::setDT(data)
}
# Separate the data by class
data_bin <- data[,bin_cols, with = FALSE]
data_cat <- data[,cat_cols, with = FALSE]
data_num <- data[,setdiff(names(data),all_names), with = FALSE]
bin_cols = bin_cols
bin_cols = bin
cat_cols = cat
data.table::setDT(data)
# Convert to data.table if data.frame
if (!("data.table" %in% class(data))) {
data.table::setDT(data)
}
# Separate the data by class
data_bin <- data[,bin_cols, with = FALSE]
data_cat <- data[,cat_cols, with = FALSE]
data_num <- data[,setdiff(names(data),all_names), with = FALSE]
# Check all column names are present
all_names <- c(bin_cols, cat_cols)
if (sum(all_names %in% names(data)) != length(all_names)) {
name_errs <- all_names[!(all_names %in% names(data))]
stop("The following column names could not be found in the data: ",
paste0("'",name_errs,sep="' "))
}
# Check no overlap between bin and cat
if (length(intersect(bin_cols, cat_cols)) > 0) {
stop("At least one variable name is duplicated in the binary and categorical arguments.")
}
# Convert to data.table if data.frame
if (!("data.table" %in% class(data))) {
data.table::setDT(data)
}
# Separate the data by class
data_bin <- data[,bin_cols, with = FALSE]
data_cat <- data[,cat_cols, with = FALSE]
data_num <- data[,setdiff(names(data),all_names), with = FALSE]
num_cols <- names(data_num)
lapply(data_num, function(x) {return(list(min = min(x, na.rm = TRUE),
max = max(x, na.rm = TRUE)))})
minmax_params <- lapply(data_num, function(x) {return(list(min = min(x, na.rm = TRUE),
max = max(x, na.rm = TRUE)))})
data_num[,(num_cols):=lapply(.SD, col_minmax),.SDcols=num_cols]
data_num
# Min-max scale
minmax_params <- NULL
data_Test <- "file/path/like/this"
class(data_Test)
class(data)
as.data.frame(data_Test)
as.data.frame(TRUE)
as.data.frame(list(c(1,2),TRUE,"hello"))
as.data.frame(lm(1:5 ~ 2:10))
as.data.frame
document()
document()
?impute
document()
?impute
document()
unload("rMIDAS")
document()
document()
convert()
test_data = data.frame(a = sample(c("red","yellow","blue",NA),100, replace = TRUE),
b = 1:100,
c = sample(c("YES","NO",NA),100,replace=TRUE),
d = runif(100,1,10),
e = sample(c("YES","NO"), 100, replace = TRUE),
f = sample(c("male","female","trans","other",NA), 100, replace = TRUE))
test_bin <- c("c","e")
test_cat <- c("a","f")
test_data <- convert(data, bin_cols = bin, cat_cols = cat, minmax_scale = TRUE)
test_data = data.frame(a = sample(c("red","yellow","blue",NA),100, replace = TRUE),
b = 1:100,
c = sample(c("YES","NO",NA),100,replace=TRUE),
d = runif(100,1,10),
e = sample(c("YES","NO"), 100, replace = TRUE),
f = sample(c("male","female","trans","other",NA), 100, replace = TRUE))
test_bin <- c("c","e")
test_cat <- c("a","f")
test_data <- convert(test_data,
bin_cols = test_bin, cat_cols = test_cat,
minmax_scale = TRUE)
View(test_data)
raw_data = data.frame(a = sample(c("red","yellow","blue",NA),1000, replace = TRUE),
b = 1:1000,
c = sample(c("YES","NO",NA),1000,replace=TRUE),
d = runif(1000,1,10),
e = sample(c("YES","NO"), 1000, replace = TRUE),
f = sample(c("male","female","trans","other",NA), 1000, replace = TRUE))
test_bin <- c("c","e")
test_cat <- c("a","f")
in_data <- convert(test_data,
bin_cols = test_bin, cat_cols = test_cat,
minmax_scale = TRUE)
test_data <- convert(raw_data,
bin_cols = test_bin, cat_cols = test_cat,
minmax_scale = TRUE)
raw_data = data.frame(a = sample(c("red","yellow","blue",NA),1000, replace = TRUE),
b = 1:1000,
c = sample(c("YES","NO",NA),1000,replace=TRUE),
d = runif(1000,1,10),
e = sample(c("YES","NO"), 1000, replace = TRUE),
f = sample(c("male","female","trans","other",NA), 1000, replace = TRUE))
test_bin <- c("c","e")
test_cat <- c("a","f")
test_data <- convert(raw_data,
bin_cols = test_bin, cat_cols = test_cat,
minmax_scale = TRUE)
raw_data['a']
raw_data[['a']]
test_data <- convert(raw_data,
bin_cols = test_bin,
cat_cols = test_cat,
minmax_scale = TRUE)
class(test_data)
data = raw_data
(class(data) == "character")
raw_data = data.frame(a = sample(c("red","yellow","blue",NA),1000, replace = TRUE),
b = 1:1000,
c = sample(c("YES","NO",NA),1000,replace=TRUE),
d = runif(1000,1,10),
e = sample(c("YES","NO"), 1000, replace = TRUE),
f = sample(c("male","female","trans","other",NA), 1000, replace = TRUE))
class(raw_data)
class(data)
class(raw_data)
data = raw_data
class(data)
(class(data) == "character")
(sum(c("data.frame","data.table") %in% class(data)) == 0)
if (class(data) == "character") {
data.table::fread(data)
} else if (sum(c("data.frame","data.table") %in% class(data)) == 0) {
data <- try(as.data.frame(data))
if ("try-error" %in% class(data)) {
stop("Cannot coerce data to data.frame")
}
}
# Check all column names are present
all_names <- c(bin_cols, cat_cols)
bin_cols = test_bin
cat_cols = test_cat
# Check all column names are present
all_names <- c(bin_cols, cat_cols)
if (sum(all_names %in% names(data)) != length(all_names)) {
name_errs <- all_names[!(all_names %in% names(data))]
stop("The following column names could not be found in the data: ",
paste0("'",name_errs,sep="' "))
}
# Check no overlap between bin and cat
if (length(intersect(bin_cols, cat_cols)) > 0) {
stop("At least one variable name is duplicated in the binary and categorical arguments.")
}
# Convert to data.table if data.frame
if (!("data.table" %in% class(data))) {
data.table::setDT(data)
}
# Separate the data by class
data_bin <- data[,bin_cols, with = FALSE]
data_cat <- data[,cat_cols, with = FALSE]
data_num <- data[,setdiff(names(data),all_names), with = FALSE]
num_cols <- names(data_num)
# One-hot encode categorical
data_cat[,(cat_cols):=lapply(.SD, as.factor),.SDcols=cat_cols]
data_cat_oh <- mltools::one_hot(data_cat, cols = names(data_cat))
names(data_cat_oh)
cat_lists <- lapply(cat_cols,
function(x) c(names(data_cat_oh)[startsWith(names(data_cat_oh),paste0(x,"_"))]))
# List to store conversions
bin_labs <- list()
for (bin_col in bin_cols) {
b_vals <- c(unique(data_bin[,bin_col, with=FALSE]))[[1]]
if (!(sum(!is.na(b_vals)) == 2)) {
stop("Column '",,"' specified in bin_cols but does not have two non-missing values")
} else if (sum(b_vals[!is.na(b_vals)] %in% c(1,2)) != 2) {
data_bin[,bin_col] <- ifelse(data_bin[,bin_col, with = FALSE] == b_vals[!is.na(b_vals)][1],
1L,0L)
}
bin_labs[[bin_col]] <- b_vals[!is.na(b_vals)]
}
# Min-max scale
minmax_params <- NULL
if (minmax_scale) {
minmax_params <- lapply(data_num, function(x) {return(list(min = min(x, na.rm = TRUE),
max = max(x, na.rm = TRUE)))})
data_num[,(num_cols):=lapply(.SD, col_minmax),.SDcols=num_cols]
}
minmax_scale = TRUE
# Min-max scale
minmax_params <- NULL
if (minmax_scale) {
minmax_params <- lapply(data_num, function(x) {return(list(min = min(x, na.rm = TRUE),
max = max(x, na.rm = TRUE)))})
data_num[,(num_cols):=lapply(.SD, col_minmax),.SDcols=num_cols]
}
data_conv <- cbind(data_num, data_bin, data_cat_oh)
type_check <- data_conv[,lapply(.SD, is.character)]
if (sum(type_check == TRUE) > 0) {
type_vars <- names(type_check)[type_check == TRUE]
warning("The following columns have not been converted to a numeric type: ",
paste0("'",type_vars, sep ="' "))
}
out <- list(data = data_conv,
bin_list = bin_labs,
cat_lists = cat_lists,
minmax_params = minmax_params)
attr(out, "class") <- "midas_preproc"
OUT
out
raw_data
class(raw_data)
raw_data = data.frame(a = sample(c("red","yellow","blue",NA),1000, replace = TRUE),
b = 1:1000,
c = sample(c("YES","NO",NA),1000,replace=TRUE),
d = runif(1000,1,10),
e = sample(c("YES","NO"), 1000, replace = TRUE),
f = sample(c("male","female","trans","other",NA), 1000, replace = TRUE))
raw_data
class(raw_data)
test_data <- convert(raw_data,
bin_cols = test_bin,
cat_cols = test_cat,
minmax_scale = TRUE)
View(data_cat)
remove.packages("rMIDAS")
getwd()
setwd("..")
install("rMIDAS")
library(devtools)
library(roxygen2)
install("rMIDAS")
library(rMIDAS)
rMIDAS::col_minmax(c(1,3,4,5,6))
raw_data = data.frame(a = sample(c("red","yellow","blue",NA),1000, replace = TRUE),
b = 1:1000,
c = sample(c("YES","NO",NA),1000,replace=TRUE),
d = runif(1000,1,10),
e = sample(c("YES","NO"), 1000, replace = TRUE),
f = sample(c("male","female","trans","other",NA), 1000, replace = TRUE))
class(raw_data)
raw_data
test_bin <- c("c","e")
test_cat <- c("a","f")
test_data <- convert(raw_data,
bin_cols = test_bin,
cat_cols = test_cat,
minmax_scale = TRUE)
library(rMIDAS)
rMIDAS::convert(raw_data)
library(reticulate)
library(mltools)
library(data.table)
test_data <- convert(raw_data,
bin_cols = test_bin,
cat_cols = test_cat,
minmax_scale = TRUE)
typeof("hello")
class("hello")
setwd("rMIDAS")
document()
convert(raw_data,
bin_cols = test_bin,
cat_cols = test_cat,
minmax_scale = TRUE)
convert(raw_data,
bin_cols = test_bin,
cat_cols = test_cat,
minmax_scale = TRUE)
class(x)
is.data.table(x)
test_data <- convert(raw_data,
bin_cols = test_bin,
cat_cols = test_cat,
minmax_scale = TRUE)
unload("rMIDAS")
